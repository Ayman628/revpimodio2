<!DOCTYPE html>
<html><head>
<title>revpimodio2.device</title>
<meta charset="UTF-8">
</head>
<body style="background-color:#FFFFFF;color:#000000"><a NAME="top" ID="top"></a>
<h1 style="background-color:#FFFFFF;color:#0000FF">
revpimodio2.device</h1>
<p>
Modul fuer die Verwaltung der Devices.
</p>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Global Attributes</h3>
<table>
<tr><td>__author__</td></tr><tr><td>__copyright__</td></tr><tr><td>__license__</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Classes</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#Base">Base</a></td>
<td>Klasse fuer alle Base-Devices wie Core / Connect usw.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Connect">Connect</a></td>
<td>Klasse fuer den RevPi Connect.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core">Core</a></td>
<td>Klasse fuer den RevPi Core.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device">Device</a></td>
<td>Basisklasse fuer alle Device-Objekte.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList">DeviceList</a></td>
<td>Basisklasse fuer direkten Zugriff auf Device Objekte.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DioModule">DioModule</a></td>
<td>Stellt ein DIO / DI / DO Modul dar.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Gateway">Gateway</a></td>
<td>Klasse fuer die RevPi Gateway-Devices.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Virtual">Virtual</a></td>
<td>Klasse fuer die RevPi Virtual-Devices.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Functions</h3>
<table>
<tr><td>None</td></tr>
</table>
<hr /><hr />
<a NAME="Base" ID="Base"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">Base</h2>
<p>
Klasse fuer alle Base-Devices wie Core / Connect usw.
</p>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
Device
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>__slots__</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>

<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr /><hr />
<a NAME="Connect" ID="Connect"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">Connect</h2>
<p>
Klasse fuer den RevPi Connect.
</p><p>
    Stellt Funktionen fuer die LEDs, Watchdog und den Status zur Verfuegung.
</p><p>

</p>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
Core
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>A3</td></tr><tr><td>__slots__</td></tr><tr><td>wdautotoggle</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#Connect.__setattr__">__setattr__</a></td>
<td>Verhindert Ueberschreibung der LEDs.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Connect.__wdtoggle">__wdtoggle</a></td>
<td>WD Ausgang alle 10 Sekunden automatisch toggeln.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Connect._devconfigure">_devconfigure</a></td>
<td>Connect-Klasse vorbereiten.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Connect._get_leda3">_get_leda3</a></td>
<td>Gibt den Zustand der LED A3 vom Connect zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Connect._get_wdtoggle">_get_wdtoggle</a></td>
<td>Ruft den Wert fuer Autowatchdog ab.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Connect._set_leda3">_set_leda3</a></td>
<td>Setzt den Zustand der LED A3 vom Connect.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Connect._set_wdtoggle">_set_wdtoggle</a></td>
<td>Setzt den Wert fuer Autowatchdog.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<a NAME="Connect.__setattr__" ID="Connect.__setattr__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Connect.__setattr__</h3>
<b>__setattr__</b>(<i>key, value</i>)
<p>
Verhindert Ueberschreibung der LEDs.
</p><a NAME="Connect.__wdtoggle" ID="Connect.__wdtoggle"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Connect.__wdtoggle</h3>
<b>__wdtoggle</b>(<i></i>)
<p>
WD Ausgang alle 10 Sekunden automatisch toggeln.
</p><a NAME="Connect._devconfigure" ID="Connect._devconfigure"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Connect._devconfigure</h3>
<b>_devconfigure</b>(<i></i>)
<p>
Connect-Klasse vorbereiten.
</p><a NAME="Connect._get_leda3" ID="Connect._get_leda3"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Connect._get_leda3</h3>
<b>_get_leda3</b>(<i></i>)
<p>
Gibt den Zustand der LED A3 vom Connect zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
0=aus, 1=gruen, 2=rot
</dd>
</dl><a NAME="Connect._get_wdtoggle" ID="Connect._get_wdtoggle"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Connect._get_wdtoggle</h3>
<b>_get_wdtoggle</b>(<i></i>)
<p>
Ruft den Wert fuer Autowatchdog ab.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn Autowatchdog aktiv ist
</dd>
</dl><a NAME="Connect._set_leda3" ID="Connect._set_leda3"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Connect._set_leda3</h3>
<b>_set_leda3</b>(<i>value</i>)
<p>
Setzt den Zustand der LED A3 vom Connect.
</p><dl>
<dt><i>value</i></dt>
<dd>
0=aus, 1=gruen, 2=rot
</dd>
</dl><a NAME="Connect._set_wdtoggle" ID="Connect._set_wdtoggle"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Connect._set_wdtoggle</h3>
<b>_set_wdtoggle</b>(<i>value</i>)
<p>
Setzt den Wert fuer Autowatchdog.
</p><p>
        Wird dieser Wert auf True gesetzt, wechselt im Hintergrund das noetige
        Bit zum toggeln des Watchdogs alle 10 Sekunden zwichen True und False.
        Dieses Bit wird bei autorefresh=True natuerlich automatisch in das
        Prozessabbild geschrieben.
</p><p>
        WICHTIG: Sollte autorefresh=False sein, muss zyklisch
                 .writeprocimg() aufgerufen werden, um den Wert in das
                 Prozessabbild zu schreiben!!!
</p><dl>
<dt><i>value</i></dt>
<dd>
True zum aktivieren, Fals zum beenden
</dd>
</dl>
<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr /><hr />
<a NAME="Core" ID="Core"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">Core</h2>
<p>
Klasse fuer den RevPi Core.
</p><p>
    Stellt Funktionen fuer die LEDs und den Status zur Verfuegung.
</p><p>

</p>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
Base
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>A1</td></tr><tr><td>A2</td></tr><tr><td>__slots__</td></tr><tr><td>status</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#Core.__errorlimit">__errorlimit</a></td>
<td>Verwaltet das Schreiben der ErrorLimits.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.__setattr__">__setattr__</a></td>
<td>Verhindert Ueberschreibung der LEDs.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core._devconfigure">_devconfigure</a></td>
<td>Core-Klasse vorbereiten.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core._get_leda1">_get_leda1</a></td>
<td>Gibt den Zustand der LED A1 vom Core zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core._get_leda2">_get_leda2</a></td>
<td>Gibt den Zustand der LED A2 vom Core zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core._get_status">_get_status</a></td>
<td>Gibt den RevPi Core Status zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core._set_calculatedled">_set_calculatedled</a></td>
<td>Berechnet und setzt neuen Bytewert fuer LED byte.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core._set_leda1">_set_leda1</a></td>
<td>Setzt den Zustand der LED A1 vom Core.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core._set_leda2">_set_leda2</a></td>
<td>Setzt den Zustand der LED A2 vom Core.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.errorlimit1">errorlimit1</a></td>
<td>Setzt RS485 ErrorLimit1 auf neuen Wert.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.errorlimit2">errorlimit2</a></td>
<td>Setzt RS485 ErrorLimit2 auf neuen Wert.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.frequency">frequency</a></td>
<td>Gibt CPU Taktfrequenz zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.iocycle">iocycle</a></td>
<td>Gibt Zykluszeit der Prozessabbildsynchronisierung zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.ioerrorcount">ioerrorcount</a></td>
<td>Gibt Fehleranzahl auf RS485 piBridge Bus zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.leftgate">leftgate</a></td>
<td>Statusbit links vom RevPi ist ein piGate Modul angeschlossen.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.missingdeviceorgate">missingdeviceorgate</a></td>
<td>Statusbit fuer ein IO-Modul fehlt oder piGate konfiguriert.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.overunderflow">overunderflow</a></td>
<td>Statusbit Modul belegt mehr oder weniger Speicher als konfiguriert.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.picontrolrunning">picontrolrunning</a></td>
<td>Statusbit fuer piControl-Treiber laeuft.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.rightgate">rightgate</a></td>
<td>Statusbit rechts vom RevPi ist ein piGate Modul angeschlossen.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.temperature">temperature</a></td>
<td>Gibt CPU-Temperatur zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Core.unconfdevice">unconfdevice</a></td>
<td>Statusbit fuer ein IO-Modul nicht mit PiCtory konfiguriert.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<a NAME="Core.__errorlimit" ID="Core.__errorlimit"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.__errorlimit</h3>
<b>__errorlimit</b>(<i>slc_io, errorlimit</i>)
<p>
Verwaltet das Schreiben der ErrorLimits.
</p><dl>
<dt><i>slc_io</i></dt>
<dd>
Byte Slice vom ErrorLimit
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
Aktuellen ErrorLimit oder None wenn nicht verfuegbar
</dd>
</dl><a NAME="Core.__setattr__" ID="Core.__setattr__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.__setattr__</h3>
<b>__setattr__</b>(<i>key, value</i>)
<p>
Verhindert Ueberschreibung der LEDs.
</p><a NAME="Core._devconfigure" ID="Core._devconfigure"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core._devconfigure</h3>
<b>_devconfigure</b>(<i></i>)
<p>
Core-Klasse vorbereiten.
</p><a NAME="Core._get_leda1" ID="Core._get_leda1"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core._get_leda1</h3>
<b>_get_leda1</b>(<i></i>)
<p>
Gibt den Zustand der LED A1 vom Core zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
0=aus, 1=gruen, 2=rot
</dd>
</dl><a NAME="Core._get_leda2" ID="Core._get_leda2"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core._get_leda2</h3>
<b>_get_leda2</b>(<i></i>)
<p>
Gibt den Zustand der LED A2 vom Core zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
0=aus, 1=gruen, 2=rot
</dd>
</dl><a NAME="Core._get_status" ID="Core._get_status"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core._get_status</h3>
<b>_get_status</b>(<i></i>)
<p>
Gibt den RevPi Core Status zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Status als <class 'int'>
</dd>
</dl><a NAME="Core._set_calculatedled" ID="Core._set_calculatedled"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core._set_calculatedled</h3>
<b>_set_calculatedled</b>(<i>addresslist, shifted_value</i>)
<p>
Berechnet und setzt neuen Bytewert fuer LED byte.
</p><dl>
<dt><i>addresslist</i></dt>
<dd>
Liste der Vergleicher
</dd><dt><i>shifed_value</i></dt>
<dd>
Bits vergleichen
</dd>
</dl><a NAME="Core._set_leda1" ID="Core._set_leda1"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core._set_leda1</h3>
<b>_set_leda1</b>(<i>value</i>)
<p>
Setzt den Zustand der LED A1 vom Core.
</p><dl>
<dt><i>value</i></dt>
<dd>
0=aus, 1=gruen, 2=rot
</dd>
</dl><a NAME="Core._set_leda2" ID="Core._set_leda2"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core._set_leda2</h3>
<b>_set_leda2</b>(<i>value</i>)
<p>
Setzt den Zustand der LED A2 vom Core.
</p><dl>
<dt><i>value</i></dt>
<dd>
0=aus, 1=gruen, 2=rot
</dd>
</dl><a NAME="Core.errorlimit1" ID="Core.errorlimit1"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.errorlimit1</h3>
<b>errorlimit1</b>(<i>value</i>)
<p>
Setzt RS485 ErrorLimit1 auf neuen Wert.
</p><dl>
<dt><i>value</i></dt>
<dd>
Neuer ErrorLimit1 Wert
</dd>
</dl><a NAME="Core.errorlimit2" ID="Core.errorlimit2"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.errorlimit2</h3>
<b>errorlimit2</b>(<i>value</i>)
<p>
Setzt RS485 ErrorLimit2 auf neuen Wert.
</p><dl>
<dt><i>value</i></dt>
<dd>
Neuer ErrorLimit2 Wert
</dd>
</dl><a NAME="Core.frequency" ID="Core.frequency"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.frequency</h3>
<b>frequency</b>(<i></i>)
<p>
Gibt CPU Taktfrequenz zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
CPU Taktfrequenz in MHz
</dd>
</dl><a NAME="Core.iocycle" ID="Core.iocycle"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.iocycle</h3>
<b>iocycle</b>(<i></i>)
<p>
Gibt Zykluszeit der Prozessabbildsynchronisierung zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Zykluszeit in ms
</dd>
</dl><a NAME="Core.ioerrorcount" ID="Core.ioerrorcount"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.ioerrorcount</h3>
<b>ioerrorcount</b>(<i></i>)
<p>
Gibt Fehleranzahl auf RS485 piBridge Bus zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Fehleranzahl der piBridge
</dd>
</dl><a NAME="Core.leftgate" ID="Core.leftgate"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.leftgate</h3>
<b>leftgate</b>(<i></i>)
<p>
Statusbit links vom RevPi ist ein piGate Modul angeschlossen.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn piGate links existiert
</dd>
</dl><a NAME="Core.missingdeviceorgate" ID="Core.missingdeviceorgate"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.missingdeviceorgate</h3>
<b>missingdeviceorgate</b>(<i></i>)
<p>
Statusbit fuer ein IO-Modul fehlt oder piGate konfiguriert.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn IO-Modul fehlt oder piGate konfiguriert
</dd>
</dl><a NAME="Core.overunderflow" ID="Core.overunderflow"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.overunderflow</h3>
<b>overunderflow</b>(<i></i>)
<p>
Statusbit Modul belegt mehr oder weniger Speicher als konfiguriert.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn falscher Speicher belegt ist
</dd>
</dl><a NAME="Core.picontrolrunning" ID="Core.picontrolrunning"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.picontrolrunning</h3>
<b>picontrolrunning</b>(<i></i>)
<p>
Statusbit fuer piControl-Treiber laeuft.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn Treiber laeuft
</dd>
</dl><a NAME="Core.rightgate" ID="Core.rightgate"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.rightgate</h3>
<b>rightgate</b>(<i></i>)
<p>
Statusbit rechts vom RevPi ist ein piGate Modul angeschlossen.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn piGate rechts existiert
</dd>
</dl><a NAME="Core.temperature" ID="Core.temperature"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.temperature</h3>
<b>temperature</b>(<i></i>)
<p>
Gibt CPU-Temperatur zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
CPU-Temperatur in Celsius
</dd>
</dl><a NAME="Core.unconfdevice" ID="Core.unconfdevice"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Core.unconfdevice</h3>
<b>unconfdevice</b>(<i></i>)
<p>
Statusbit fuer ein IO-Modul nicht mit PiCtory konfiguriert.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn IO Modul nicht konfiguriert
</dd>
</dl>
<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr /><hr />
<a NAME="Device" ID="Device"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">Device</h2>
<p>
Basisklasse fuer alle Device-Objekte.
</p><p>
    Die Basisfunktionalitaet generiert bei Instantiierung alle IOs und
    erweitert den Prozessabbildpuffer um die benoetigten Bytes. Sie verwaltet
    ihren Prozessabbildpuffer und sorgt fuer die Aktualisierung der IO-Werte.
</p><p>

</p>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
object
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>__slots__</td></tr><tr><td>length</td></tr><tr><td>name</td></tr><tr><td>offset</td></tr><tr><td>position</td></tr><tr><td>producttype</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#Device.__init__">Device</a></td>
<td>Instantiierung der Device-Klasse.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__bytes__">__bytes__</a></td>
<td>Gibt alle Daten des Devices als <class 'bytes'> zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__contains__">__contains__</a></td>
<td>Prueft ob IO auf diesem Device liegt.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__getioiter">__getioiter</a></td>
<td>Gibt <class 'iter'> mit allen IOs zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__getitem__">__getitem__</a></td>
<td>Gibt IO an angegebener Stelle zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__int__">__int__</a></td>
<td>Gibt die Positon im RevPi Bus zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__iter__">__iter__</a></td>
<td>Gibt Iterator aller IOs zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__len__">__len__</a></td>
<td>Gibt Anzahl der Bytes zurueck, die dieses Device belegt.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.__str__">__str__</a></td>
<td>Gibt den Namen des Devices zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device._buildio">_buildio</a></td>
<td>Erstellt aus der piCtory-Liste die IOs fuer dieses Device.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device._devconfigure">_devconfigure</a></td>
<td>Funktion zum ueberschreiben von abgeleiteten Klassen.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device._get_offset">_get_offset</a></td>
<td>Gibt den Deviceoffset im Prozessabbild zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device._get_producttype">_get_producttype</a></td>
<td>Gibt den Produkttypen des device zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device._update_my_io_list">_update_my_io_list</a></td>
<td>Erzeugt eine neue IO Liste fuer schnellen Zugriff.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.autorefresh">autorefresh</a></td>
<td>Registriert dieses Device fuer die automatische Synchronisierung.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.get_allios">get_allios</a></td>
<td>Gibt eine Liste aller Inputs und Outputs zurueck, keine MEMs.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.get_inputs">get_inputs</a></td>
<td>Gibt eine Liste aller Inputs zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.get_memories">get_memories</a></td>
<td>Gibt eine Liste aller Memoryobjekte zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.get_outputs">get_outputs</a></td>
<td>Gibt eine Liste aller Outputs zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.readprocimg">readprocimg</a></td>
<td>Alle Inputs fuer dieses Device vom Prozessabbild einlesen.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.setdefaultvalues">setdefaultvalues</a></td>
<td>Alle Outputbuffer fuer dieses Device auf default Werte setzen.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.syncoutputs">syncoutputs</a></td>
<td>Lesen aller Outputs im Prozessabbild fuer dieses Device.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Device.writeprocimg">writeprocimg</a></td>
<td>Schreiben aller Outputs dieses Devices ins Prozessabbild.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<a NAME="Device.__init__" ID="Device.__init__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device (Constructor)</h3>
<b>Device</b>(<i>parentmodio, dict_device, simulator=False</i>)
<p>
Instantiierung der Device-Klasse.
</p><dl>
<dt><i>parent</i></dt>
<dd>
RevpiModIO parent object
</dd><dt><i>dict_device</i></dt>
<dd>
<class 'dict'> fuer dieses Device aus piCotry
</dd><dt><i>simulator:</i></dt>
<dd>
Laedt das Modul als Simulator und vertauscht IOs
</dd>
</dl><a NAME="Device.__bytes__" ID="Device.__bytes__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__bytes__</h3>
<b>__bytes__</b>(<i></i>)
<p>
Gibt alle Daten des Devices als <class 'bytes'> zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Devicedaten als <class 'bytes'>
</dd>
</dl><a NAME="Device.__contains__" ID="Device.__contains__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__contains__</h3>
<b>__contains__</b>(<i>key</i>)
<p>
Prueft ob IO auf diesem Device liegt.
</p><dl>
<dt><i>key</i></dt>
<dd>
IO-Name <class 'str'> / IO-Bytenummer <class 'int'>
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
True, wenn IO auf Device vorhanden
</dd>
</dl><a NAME="Device.__getioiter" ID="Device.__getioiter"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__getioiter</h3>
<b>__getioiter</b>(<i>ioslc, export</i>)
<p>
Gibt <class 'iter'> mit allen IOs zurueck.
</p><dl>
<dt><i>ioslc</i></dt>
<dd>
IO Abschnitt <class 'slice'>
</dd><dt><i>export</i></dt>
<dd>
Filter fuer 'Export' Flag in piCtory
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
IOs als Iterator
</dd>
</dl><a NAME="Device.__getitem__" ID="Device.__getitem__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__getitem__</h3>
<b>__getitem__</b>(<i>key</i>)
<p>
Gibt IO an angegebener Stelle zurueck.
</p><dl>
<dt><i>key</i></dt>
<dd>
Index des IOs auf dem device als <class 'int'>
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
Gefundenes IO-Objekt
</dd>
</dl><a NAME="Device.__int__" ID="Device.__int__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__int__</h3>
<b>__int__</b>(<i></i>)
<p>
Gibt die Positon im RevPi Bus zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Positionsnummer
</dd>
</dl><a NAME="Device.__iter__" ID="Device.__iter__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__iter__</h3>
<b>__iter__</b>(<i></i>)
<p>
Gibt Iterator aller IOs zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
<class 'iter'> aller IOs
</dd>
</dl><a NAME="Device.__len__" ID="Device.__len__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__len__</h3>
<b>__len__</b>(<i></i>)
<p>
Gibt Anzahl der Bytes zurueck, die dieses Device belegt.
</p><dl>
<dt>Returns:</dt>
<dd>
<class 'int'>
</dd>
</dl><a NAME="Device.__str__" ID="Device.__str__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.__str__</h3>
<b>__str__</b>(<i></i>)
<p>
Gibt den Namen des Devices zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Devicename
</dd>
</dl><a NAME="Device._buildio" ID="Device._buildio"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device._buildio</h3>
<b>_buildio</b>(<i>dict_io, iotype</i>)
<p>
Erstellt aus der piCtory-Liste die IOs fuer dieses Device.
</p><dl>
<dt><i>dict_io</i></dt>
<dd>
<class 'dict'>-Objekt aus piCtory Konfiguration
</dd><dt><i>iotype</i></dt>
<dd>
<class 'int'> Wert
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
<class 'slice'> mit Start und Stop Position dieser IOs
</dd>
</dl><a NAME="Device._devconfigure" ID="Device._devconfigure"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device._devconfigure</h3>
<b>_devconfigure</b>(<i></i>)
<p>
Funktion zum ueberschreiben von abgeleiteten Klassen.
</p><a NAME="Device._get_offset" ID="Device._get_offset"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device._get_offset</h3>
<b>_get_offset</b>(<i></i>)
<p>
Gibt den Deviceoffset im Prozessabbild zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Deviceoffset
</dd>
</dl><a NAME="Device._get_producttype" ID="Device._get_producttype"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device._get_producttype</h3>
<b>_get_producttype</b>(<i></i>)
<p>
Gibt den Produkttypen des device zurueck.
</p><dl>
<dt>Returns:</dt>
<dd>
Deviceprodukttyp
</dd>
</dl><a NAME="Device._update_my_io_list" ID="Device._update_my_io_list"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device._update_my_io_list</h3>
<b>_update_my_io_list</b>(<i></i>)
<p>
Erzeugt eine neue IO Liste fuer schnellen Zugriff.
</p><a NAME="Device.autorefresh" ID="Device.autorefresh"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.autorefresh</h3>
<b>autorefresh</b>(<i>activate=True</i>)
<p>
Registriert dieses Device fuer die automatische Synchronisierung.
</p><dl>
<dt><i>activate</i></dt>
<dd>
Default True fuegt Device zur Synchronisierung hinzu
</dd>
</dl><a NAME="Device.get_allios" ID="Device.get_allios"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.get_allios</h3>
<b>get_allios</b>(<i>export=None</i>)
<p>
Gibt eine Liste aller Inputs und Outputs zurueck, keine MEMs.
</p><p>
        Bleibt Parameter 'export' auf None werden alle Inputs und Outputs
        zurueckgegeben. Wird 'export' auf True/False gesetzt, werden nur Inputs
        und Outputs zurueckgegeben, bei denen der Wert 'Export' in piCtory
        uebereinstimmt.
</p><dl>
<dt><i>export</i></dt>
<dd>
Nur In-/Outputs mit angegebenen 'Export' Wert in piCtory
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
<class 'list'> Input und Output, keine MEMs
</dd>
</dl><a NAME="Device.get_inputs" ID="Device.get_inputs"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.get_inputs</h3>
<b>get_inputs</b>(<i>export=None</i>)
<p>
Gibt eine Liste aller Inputs zurueck.
</p><p>
        Bleibt Parameter 'export' auf None werden alle Inputs zurueckgegeben.
        Wird 'export' auf True/False gesetzt, werden nur Inputs zurueckgegeben,
        bei denen der Wert 'Export' in piCtory uebereinstimmt.
</p><dl>
<dt><i>export</i></dt>
<dd>
Nur Inputs mit angegebenen 'Export' Wert in piCtory
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
<class 'list'> Inputs
</dd>
</dl><a NAME="Device.get_memories" ID="Device.get_memories"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.get_memories</h3>
<b>get_memories</b>(<i>export=None</i>)
<p>
Gibt eine Liste aller Memoryobjekte zurueck.
</p><p>
        Bleibt Parameter 'export' auf None werden alle Mems zurueckgegeben.
        Wird 'export' auf True/False gesetzt, werden nur Mems zurueckgegeben,
        bei denen der Wert 'Export' in piCtory uebereinstimmt.
</p><dl>
<dt><i>export</i></dt>
<dd>
Nur Mems mit angegebenen 'Export' Wert in piCtory
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
<class 'list'> Mems
</dd>
</dl><a NAME="Device.get_outputs" ID="Device.get_outputs"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.get_outputs</h3>
<b>get_outputs</b>(<i>export=None</i>)
<p>
Gibt eine Liste aller Outputs zurueck.
</p><p>
        Bleibt Parameter 'export' auf None werden alle Outputs zurueckgegeben.
        Wird 'export' auf True/False gesetzt, werden nur Outputs
        zurueckgegeben, bei denen der Wert 'Export' in piCtory uebereinstimmt.
</p><dl>
<dt><i>export</i></dt>
<dd>
Nur Outputs mit angegebenen 'Export' Wert in piCtory
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
<class 'list'> Outputs
</dd>
</dl><a NAME="Device.readprocimg" ID="Device.readprocimg"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.readprocimg</h3>
<b>readprocimg</b>(<i></i>)
<p>
Alle Inputs fuer dieses Device vom Prozessabbild einlesen.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn erfolgreich ausgefuehrt
</dd>
</dl><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="revpimodio2.modio.html#RevPiModIO.readprocimg">RevPiModIO.readprocimg()</a>
</dd>
</dl><a NAME="Device.setdefaultvalues" ID="Device.setdefaultvalues"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.setdefaultvalues</h3>
<b>setdefaultvalues</b>(<i></i>)
<p>
Alle Outputbuffer fuer dieses Device auf default Werte setzen.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn erfolgreich ausgefuehrt
</dd>
</dl><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="revpimodio2.modio.html#RevPiModIO.setdefaultvalues">RevPiModIO.setdefaultvalues()</a>
</dd>
</dl><a NAME="Device.syncoutputs" ID="Device.syncoutputs"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.syncoutputs</h3>
<b>syncoutputs</b>(<i></i>)
<p>
Lesen aller Outputs im Prozessabbild fuer dieses Device.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn erfolgreich ausgefuehrt
</dd>
</dl><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="revpimodio2.modio.html#RevPiModIO.syncoutputs">RevPiModIO.syncoutputs()</a>
</dd>
</dl><a NAME="Device.writeprocimg" ID="Device.writeprocimg"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Device.writeprocimg</h3>
<b>writeprocimg</b>(<i></i>)
<p>
Schreiben aller Outputs dieses Devices ins Prozessabbild.
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn erfolgreich ausgefuehrt
</dd>
</dl><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="revpimodio2.modio.html#RevPiModIO.writeprocimg">RevPiModIO.writeprocimg()</a>
</dd>
</dl>
<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr /><hr />
<a NAME="DeviceList" ID="DeviceList"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">DeviceList</h2>
<p>
Basisklasse fuer direkten Zugriff auf Device Objekte.
</p>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
object
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#DeviceList.__init__">DeviceList</a></td>
<td>Init DeviceList class.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList.__contains__">__contains__</a></td>
<td>Prueft ob Device existiert.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList.__delattr__">__delattr__</a></td>
<td>Entfernt angegebenes Device.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList.__delitem__">__delitem__</a></td>
<td>Entfernt Device an angegebener Position.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList.__getitem__">__getitem__</a></td>
<td>Gibt angegebenes Device zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList.__iter__">__iter__</a></td>
<td>Gibt Iterator aller Devices zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList.__len__">__len__</a></td>
<td>Gibt Anzahl der Devices zurueck.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#DeviceList.__setattr__">__setattr__</a></td>
<td>Setzt Attribute nur wenn Device.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<a NAME="DeviceList.__init__" ID="DeviceList.__init__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList (Constructor)</h3>
<b>DeviceList</b>(<i></i>)
<p>
Init DeviceList class.
</p><a NAME="DeviceList.__contains__" ID="DeviceList.__contains__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList.__contains__</h3>
<b>__contains__</b>(<i>key</i>)
<p>
Prueft ob Device existiert.
</p><dl>
<dt><i>key</i></dt>
<dd>
DeviceName <class 'str'> / Positionsnummer <class 'int'>
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
True, wenn Device vorhanden
</dd>
</dl><a NAME="DeviceList.__delattr__" ID="DeviceList.__delattr__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList.__delattr__</h3>
<b>__delattr__</b>(<i>key, delcomplete=True</i>)
<p>
Entfernt angegebenes Device.
</p><dl>
<dt><i>key</i></dt>
<dd>
Device zum entfernen
</dd><dt><i>delcomplete</i></dt>
<dd>
Wenn True wird Device komplett entfernt
</dd>
</dl><a NAME="DeviceList.__delitem__" ID="DeviceList.__delitem__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList.__delitem__</h3>
<b>__delitem__</b>(<i>key</i>)
<p>
Entfernt Device an angegebener Position.
</p><dl>
<dt><i>key</i></dt>
<dd>
Deviceposition zum entfernen
</dd>
</dl><a NAME="DeviceList.__getitem__" ID="DeviceList.__getitem__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList.__getitem__</h3>
<b>__getitem__</b>(<i>key</i>)
<p>
Gibt angegebenes Device zurueck.
</p><dl>
<dt><i>key</i></dt>
<dd>
DeviceName <class 'str'> / Positionsnummer <class 'int'>
</dd>
</dl><dl>
<dt>Returns:</dt>
<dd>
Gefundenes <class 'Device'>-Objekt
</dd>
</dl><a NAME="DeviceList.__iter__" ID="DeviceList.__iter__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList.__iter__</h3>
<b>__iter__</b>(<i></i>)
<p>
Gibt Iterator aller Devices zurueck.
</p><p>
        Die Reihenfolge ist nach Position im Prozessabbild sortiert und nicht
        nach Positionsnummer (Dies entspricht der Positionierung aus piCtory)!
</p><dl>
<dt>Returns:</dt>
<dd>
<class 'iter'> aller Devices
</dd>
</dl><a NAME="DeviceList.__len__" ID="DeviceList.__len__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList.__len__</h3>
<b>__len__</b>(<i></i>)
<p>
Gibt Anzahl der Devices zurueck.
        return Anzahl der Devices
</p><a NAME="DeviceList.__setattr__" ID="DeviceList.__setattr__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DeviceList.__setattr__</h3>
<b>__setattr__</b>(<i>key, value</i>)
<p>
Setzt Attribute nur wenn Device.
</p><dl>
<dt><i>key</i></dt>
<dd>
Attributname
</dd><dt><i>value</i></dt>
<dd>
Attributobjekt
</dd>
</dl>
<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr /><hr />
<a NAME="DioModule" ID="DioModule"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">DioModule</h2>
<p>
Stellt ein DIO / DI / DO Modul dar.
</p>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
Device
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>__slots__</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#DioModule.__init__">DioModule</a></td>
<td>Erweitert Device-Klasse zum Erkennen von IntIOCounter.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<a NAME="DioModule.__init__" ID="DioModule.__init__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
DioModule (Constructor)</h3>
<b>DioModule</b>(<i>parentmodio, dict_device, simulator=False</i>)
<p>
Erweitert Device-Klasse zum Erkennen von IntIOCounter.
</p><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="#Device.__init__">Device.__init__(...)</a>
</dd>
</dl>
<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr /><hr />
<a NAME="Gateway" ID="Gateway"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">Gateway</h2>
<p>
Klasse fuer die RevPi Gateway-Devices.
</p><p>
    Stellt neben den Funktionen von RevPiDevice weitere Funktionen fuer die
    Gateways bereit. IOs auf diesem Device stellen die replace_io Funktion
    zur verfuegung, ueber die eigene IOs definiert werden, die ein
    RevPiStructIO-Objekt abbilden.
    Dieser IO-Typ kann Werte ueber mehrere Bytes verarbeiten und zurueckgeben.
</p><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="revpimodio2.io.html#IntIOReplaceable.replace_io">replace_io(...)</a>
</dd>
</dl>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
Device
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>__slots__</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#Gateway.__init__">Gateway</a></td>
<td>Erweitert Device-Klasse um get_rawbytes-Funktionen.</td>
</tr><tr>
<td><a style="color:#0000FF" href="#Gateway.get_rawbytes">get_rawbytes</a></td>
<td>Gibt die Bytes aus, die dieses Device verwendet.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<a NAME="Gateway.__init__" ID="Gateway.__init__"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Gateway (Constructor)</h3>
<b>Gateway</b>(<i>parent, dict_device, simulator=False</i>)
<p>
Erweitert Device-Klasse um get_rawbytes-Funktionen.
</p><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="#Device.__init__">Device.__init__(...)</a>
</dd>
</dl><a NAME="Gateway.get_rawbytes" ID="Gateway.get_rawbytes"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Gateway.get_rawbytes</h3>
<b>get_rawbytes</b>(<i></i>)
<p>
Gibt die Bytes aus, die dieses Device verwendet.
</p><dl>
<dt>Returns:</dt>
<dd>
<class 'bytes'> des Devices
</dd>
</dl>
<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr /><hr />
<a NAME="Virtual" ID="Virtual"></a>
<h2 style="background-color:#FFFFFF;color:#0000FF">Virtual</h2>
<p>
Klasse fuer die RevPi Virtual-Devices.
</p><p>
    Stellt die selben Funktionen wie Gateway zur Verfuegung. Es koennen
    ueber die reg_*-Funktionen eigene IOs definiert werden, die ein
    RevPiStructIO-Objekt abbilden.
    Dieser IO-Typ kann Werte ueber mehrere Bytes verarbeiten und zurueckgeben.
</p><dl>
<dt><b>See Also:</b></dt>
<dd>
<a style="color:#0000FF" href="#Gateway">Gateway</a>
</dd>
</dl>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Derived from</h3>
Gateway
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Attributes</h3>
<table>
<tr><td>__slots__</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Class Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Methods</h3>
<table>
<tr>
<td><a style="color:#0000FF" href="#Virtual.writeinputdefaults">writeinputdefaults</a></td>
<td>Schreibt fuer ein virtuelles Device piCtory Defaultinputwerte.</td>
</tr>
</table>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Static Methods</h3>
<table>
<tr><td>None</td></tr>
</table>
<a NAME="Virtual.writeinputdefaults" ID="Virtual.writeinputdefaults"></a>
<h3 style="background-color:#FFFFFF;color:#FF0000">
Virtual.writeinputdefaults</h3>
<b>writeinputdefaults</b>(<i></i>)
<p>
Schreibt fuer ein virtuelles Device piCtory Defaultinputwerte.
</p><p>
        Sollten in piCtory Defaultwerte fuer Inputs eines virtuellen Devices
        angegeben sein, werden diese nur beim Systemstart oder einem piControl
        Reset gesetzt. Sollte danach das Prozessabbild mit NULL ueberschrieben,
        gehen diese Werte verloren.
        Diese Funktion kann nur auf virtuelle Devices angewendet werden!
</p><dl>
<dt>Returns:</dt>
<dd>
True, wenn Arbeiten am virtuellen Device erfolgreich waren
</dd>
</dl>
<div align="right"><a style="color:#0000FF" href="#top">Up</a></div>
<hr />
</body></html>